---
title: "http,TCP/IP 详解"
date: 2019-09-16T17:49:50+08:00
draft: false
toc: true
categories: ["技术"]
series: ["网络"]
tags: ["go","面试","网络"]
toc: false
---

#### [转载至头条号猪哥亮额](https://www.toutiao.com/i6480290584140448269/)


**TCP/IP**
TCP/IP是一个协议簇，是由许多协议组成的。

**TCP/IP四层模型**
TCP/IP按照层次从上至下分为四层：应用层，传输层，网络层，数据链路层。（实际上最初理论上OSI模型是分的七层，我们程序猿的话通常只用分四层就行了。）

![模型](/images/blog/2019/tcp_1.jpg)

1.应用层

   应用层决定了向用户提供应用服务时通信的活动。TCP/IP协议族内预存了各类通用的应用服务。比如，FTP（File Transfer Protocol，文件传输协议）和DNS（Domain Name System，域名系统）服务就是其中两类。HTTP协议也处于该层。

2.传输层

   传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据传输。在传输层有两个性质不同的协议：TCP（Transmission ControlProtocol，传输控制协议）和UDP（User Data Protocol，用户数据报协议）。

3.网络层

   网络层用来处理在网络上流动的数据包。数据包是网络传输的最小数据单位。该层规定了通过怎样的路径（所谓的传输路线）到达对方计算机，并把数据包传送给对方。与对方计算机之间通过多台计算机或网络设备进行传输时，网络层所起的作用就是在众多的选项内选择一条传输路线。

4.链路层（又名数据链路层，网络接口层）

   用来处理连接网络的硬件部分。包括控制操作系统、硬件的设备驱动、NIC（Network Interface Card，网络适配器，即网卡），及光纤等物理可见部分（还包括连接器等一切传输媒介）。硬件上的范畴均在链路层的作用范围之内。
   
TCP/IP具体是怎么通信的呢？
- 利用TCP/IP协议族进行网络通信时，会通过分层顺序与对方进行通信。发送端从应用层往下走，接收端则往应用层往上走。我们用HTTP举例来说明，首先作为发送端的客户端在应用层（HTTP协议）发出一个想看某个Web页面的HTTP请求。接着，为了传输方便，在传输层（TCP协议）把从应用层处收到的数据（HTTP请求报文）进行分割，并在各个报文上打上标记序号及端口号后转发给网络层。在网络层（IP协议），增加作为通信目的地的MAC地址后转发给链路层。这样一来，发往网络的通信请求就准备齐全了。接收端的服务器在链路层接收到数据，按序往上层发送，一直到应用层。当传输到应用层，才能算真正接收到由客户端发送过来的HTTP请求。

![http的传递](/images/blog/2019/tcp_2.jpg)

- 发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的首部信息。反之，接收端在层与层传输数据时，每经过一层时会把对应的首部消去。这种把数据信息包装起来的做法称为封装（encapsulate）。

![http的报文](/images/blog/2019/tcp_3.jpg)

负责传输的IP协议。

- 按层次分，IP（Internet Protocol）网际协议位于网络层。Internet Protocol这个名称可能听起来有点夸张，但事实正是如此，因为几乎所有使用网络的系统都会用到IP协议。TCP/IP协议族中的IP指的就是网际协议，协议名称中占据了一半位置，其重要性可见一斑。可能有人会把IP和IP 地址搞混，IP其实是一种协议的名称。

- IP协议的作用是把各种数据包传送给对方。而要保证确实传送到对方那里，则需要满足各类条件。其中两个重要的条件是IP地址和MAC地址（Media Access Control Address）。IP地址指明了节点被分配到的地址，MAC地址是指网卡所属的固定地址。IP地址可以和MAC地址进行配对。IP地址可变换，但MAC地址基本上不会更改。

- 使用ARP协议凭借MAC地址进行通信。IP间的通信依赖MAC地址。在网络上，通信的双方在同一局域网（LAN）内的情况是很少的，通常是经过多台计算机和网络设备中转才能连接到对方。而在进行中转时，会利用下一站中转设备的MAC地址来搜索下一个中转目标。这时，会采用ARP协议（Address Resolution Protocol）。ARP 是一种用以解析地址的协议，根据通信方的IP地址就可以反查出对应的MAC地址。

- 没有人能够全面掌握互联网中的传输状况，即在传输过程中每一个节点只需要了解下一个节点的信息，再往下的信息就交给下个节点去处理就行了。在到达通信目标前的中转过程中，那些计算机和路由器等网络设备只能获悉很粗略的传输路线。 这种机制称为路由选择（routing），有点像快递公司的送货过程。想要寄快递的人，只要将自己的货物送到集散中心，就可以知道快递公司是否肯收件发货，该快递公司的集散中心检查货物的送达地址，明确下站该送往哪个区域的集散中心。接着，那个区域的集散中心自会判断是否能送到对方的家中。我们是想通过这个比喻说明，无论哪台计算机、哪台网络设备，它们都无法全面掌握互联网中的细节。

![tcp握手](/images/blog/2019/tcp_4.jpg)

确保可靠性的TCP协议。
- 按层次分，TCP位于传输层，提供可靠的字节流服务。所谓的字节流服务（Byte Stream Service）是指，为了方便传输，将大块数据分割成以报文段（segment）为单位的数据包进行管理。而可靠的传输服务是指，能够把数据准确可靠地传给对方。一言以蔽之，TCP协议为了更容易传送大数据才把数据分割，而且TCP协议能够确认数据最终是否送达到对方。

- 确保数据能到达目标。为了准确无误地将数据送达目标处，TCP协议采用了三次握手（three-way handshaking）策略。用TCP协议把数据包送出去后，TCP不会对传送后的情况置之不理，它一定会向对方确认是否成功送达。握手过程中使用了TCP的标志（flag） ——SYN（synchronize） 和ACK（acknowledgement）。发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息。最后，发送端再回传一个带ACK标志的数据包，代表握手结束。若在握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包。除了上述三次握手，TCP协议还有其他各种手段来保证通信的可靠性。

![tcp握手](/images/blog/2019/tcp_5.jpg)

负责域名解析的DNS服务。

- DNS（Domain Name System）服务是和HTTP协议一样位于应用层的协议。它提供域名到IP地址之间的解析服务。计算机既可以被赋予IP地址，也可以被赋予主机名和域名。比如www.baidu.com。因为域名更加直观，所以用户通常使用主机名或域名来访问对方的计算机，而不是直接通过IP地址访问。但要让计算机去理解名称，相对而言就变得困难了。因为计算机更擅长处理一长串数字。为了解决上述的问题，DNS服务应运而生。DNS协议提供通过域名查找IP地址，或逆向从IP地址反查域名的服务。

![dns解析](/images/blog/2019/dns_1.jpg)

HTTP协议与其他TCP/IP协议是如何协作的？

![协议之间的协作](/images/blog/2019/tcp_6.jpg)

**URI和URL**

URI是Uniform Resource Identifier的缩写，即统一资源标识符。
- RFC2396分别对这 3 个单词进行了如下定义：

- Uniform ：规定统一的格式可方便处理多种不同类型的资源， 而不用根据上下文环境来识别资源指定的访问方式。另外， 加入新增的协议方案（如http:或ftp:） 也更容易。

- Resource ：资源的定义是可标识的任何东西。 除了文档文件、 图像或服务（例如当天的天气预报） 等能够区别于其他类型的， 全都可作为资源。 另外， 资源不仅可以是单一的， 也可以是多数的集合体。

- Identifier ：表示可标识的对象。 也称为标识符。

- 综上所述，URI就是由某个协议方案表示的资源的定位标识符。 协议方案是指访问资源所使用的协议类型名称。 采用HTTP协议时， 协议方案就是http。 除此之外， 还有ftp、mailto、telnet、file等。 标准的URI协议方案有 30 种左右， 由隶属于国际互联网资源管理的非营利社团ICANN（Internet Corporation for Assigned Names and Numbers， 互联网名称与数字地址分配机构） 的IANA（Internet Assigned Numbers Authority， 互联网号码分配局） 管理

- URI用字符串标识某一互联网资源， 而URL表示资源的地点（互联网上所处的位置） 。 可见URL是URI的子集。（当然通常可以大致把URL理解成URI）

URI的格式。

- 要想表示指定的资源， 就得使用涵盖全部必要信息的绝对URI，同样的也会有相对URI。这里以相对URL为例，就是指从浏览器中基本URL处指定的URL，形如/image/logo.gif这种形式。

接下来结合下面这个例子着重介绍一下绝对URI：

![uri](/images/blog/2019/uri.jpg)

- 协议方案名：使用http:或https:等协议方案名获取访问资源时要指定协议类型。 不区分字母大小写， 最后附一个冒号（:）。也可使用data:或javascript:这类指定数据或脚本程序的方案名。

- 登录信息（认证） ：指定用户名和密码作为从服务器端获取资源时必要的登录信息（身份认证） 。 此项是可选项。

- 服务器地址 ：使用绝对URI必须指定待访问的服务器地址。 地址可以是类似baidu.com这种DNS可解析的域名， 或是192.168.1.1这类IPv4地址， 还可以是[0:0:0:0:0:0:0:1]这样用方括号括起来的IPv6地址。

- 服务器端口号 :指定服务器连接的网络端口号。 此项也是可选项， 若用户省略则自动使用默认端口号。

- 带层次的文件路径 :指定服务器上的文件路径来定位特指的资源。 这与UNIX系统的文件目录结构相似。

- 查询字符串 :针对已指定的文件路径内的资源， 可以使用查询字符串传入任意参数。 此项可选。

- 片段标识符 :使用片段标识符通常可标记出已获取资源中的子资源（文档内的某个位置） 。 但在RFC中并没有明确规定其使用方法。 该项也为可选项。

RFC : Request for Comments， 征求修正意见书。一些用来制定HTTP协议技术标准的文档，当然并不是强制性的，所以还是有一小部分应用程序并没有遵从RFC标准，这也就导致了其他应用不同标准的互联网资源可能就无法与该应用程序进行通讯了。

- RFC3986列举了几种URI的常用语法格式：
  - `tp://ftp.is.co.za/rfc/rfc1808.txt`
  - `http://www.ietf.org/rfc/rfc2396.txt`
  - `ldap://[2001:db8::7]/c=GB?objectClass?one`
  - `mailto:John.Doe@example.com`
  - `news:comp.infosystems.www.servers.unix`
  - `tel:+1-816-555-1212`
  - `telnet://192.0.2.16:80/`
  - `urn:oasis:names:specification:docbook:dtd:xml:4.1.2`
 
HTTP协议用于客户端和服务器端之间的通信。

- HTTP协议和TCP/IP协议族内的其他众多的协议相同， 用于客户端和服务器之间的通信。请求访问文本或图像等资源的一端称为客户端， 而提供资源响应的一端称为服务器端。在两台计算机之间使用HTTP协议通信时， 在一条通信线路上必定有一端是客户端， 另一端则是服务器端。有时候， 按实际情况， 两台计算机作为客户端和服务器端的角色有可能会互换。 但就仅从一条通信路线来说， 服务器端和客户端的角色是确定的， 而用HTTP协议能够明确区分哪端是客户端， 哪端是服务器端。
![server](/images/blog/2019/tcp_7.jpg)

通过请求和响应的交换达成通信。
  ![server](/images/blog/2019/tcp_8.jpg)

- HTTP协议规定， 请求从客户端发出， 最后服务器端响应该请求并返回。 换句话说， 肯定是先从客户端开始建立通信的， 服务器端在没有接收到请求之前不会发送响应。
  ![http](/images/blog/2019/http_1.jpg)

- 起始行开头的GET表示请求访问服务器的类型， 称为方法（method） 。 随后的字符串/index.htm指明了请求访问的资源对象，也叫做请求URI（request-URI） 。 最后的HTTP/1.1， 即HTTP的版本号， 用来提示客户端使用的HTTP协议功能。综合来看， 这段请求内容的意思是： 请求访问某台HTTP服务器上的/index.htm页面资源。

- 请求报文是由请求方法、 请求URI、 协议版本、 可选的请求首部字段和内容实体构成的。
  ![http](/images/blog/2019/http_2.jpg)
- 紧挨着的200 OK表示请求的处理结果的状态码（status code） 和原因短语（reason-phrase） 。 下一行显示了创建响应的日期时间， 是首部字段（header field） 内的一个属性。接着以一空行分隔， 之后的内容称为资源实体的主体（entity body）。响应报文基本上由协议版本、 状态码（表示请求成功或失败的数字代 码） 、 用以解释状态码的原因短语、 可选的响应首部字段以及实体主体构成。 稍后我们会对这些内容进行详细说明。

HTTP是不保存状态的协议。

- HTTP是一种不保存状态， 即无状态（stateless） 协议。HTTP协议自身不对请求和响应之间的通信状态进行保存。 也就是说在HTTP这个级别， 协议对于发送过的请求或响应都不做持久化处理。
   ![http](/images/blog/2019/http_3.jpg)
- 使用HTTP协议， 每当有新的请求发送时， 就会有对应的新响应产生。 协议本身并不保留之前一切的请求或响应报文的信息。 这是为了更快地处理大量事务， 确保协议的可伸缩性， 而特意把HTTP协议设计成如此简单的。可是， 随着Web的不断发展， 因无状态而导致业务处理变得棘手的情况增多了。 比如， 用户登录到一家购物网站， 即使他跳转到该站的其他页面后， 也需要能继续保持登录状态。 针对这个实例， 网站为了能够掌握是谁送出的请求， 需要保存用户的状态。HTTP/1.1虽然是无状态协议， 但为了实现期望的保持状态功能， 于是引入了Cookie技术。 有了Cookie再用HTTP协议通信， 就可以管理状态了。 有关Cookie的详细内容稍后讲解。

请求URI定位资源

- HTTP协议使用URI定位互联网上的资源。 正是因为URI的特定功能， 在互联网上任意位置的资源都能访问到。

![http](/images/blog/2019/http_4.jpg)

- 当客户端请求访问资源而发送请求时，URI需要将作为请求报文中的请求URI包含在内。 指定请求URI的方式有很多。

![http](/images/blog/2019/http_5.jpg)

- 除此之外， 如果不是访问特定资源而是对服务器本身发起请求， 可以用一个*来代替请求URI。 下面这个例子是查询HTTP服务器端支持的HTTP方法种类。

![http](/images/blog/2019/http_6.jpg)

告知服务器意图的HTTP方法。
- 向请求URI指定的资源发送请求报文时， 采用称为方法的命令。方法的作用在于， 可以指定请求的资源按期望产生某种行为。 方法中有GET、POST和HEAD等。

![http](/images/blog/2019/http_7.jpg)

- 下表列出了HTTP/1.0和HTTP/1.1支持的方法。 另外， 方法名区分大小写， 注意要用大写字母。

![http](/images/blog/2019/http_8.jpg)

在这里列举的众多方法中，LINK和UNLINK已被HTTP/1.1废弃， 不再支持。

GET： 获取资源。

- GET方法用来请求访问已被URI识别的资源。 指定的资源经服务器端解析后返回响应内容。 也就是说， 如果请求的资源是文本， 那就保持原样返回； 如果是像CGI（Common Gateway Interface， 通用网关接口）那样的程序， 则返回经过执行后的输出结果。

![http](/images/blog/2019/http_get.jpg)
![http](/images/blog/2019/http_get2.jpg)

POST： 传输实体主体。

- 虽然用GET方法也可以传输实体的主体， 但一般不用GET方法进行传输， 而是用POST方法。 虽说POST的功能与GET很相似， 但POST的主要目的并不是获取响应的主体内容。

![http](/images/blog/2019/http_post.jpg)
![http](/images/blog/2019/http_post2.jpg)

PUT： 传输文件。

- PUT方法用来传输文件。 就像FTP协议的文件上传一样， 要求在请求报文的主体中包含文件内容， 然后保存到请求URI指定的位置。但是， 鉴于HTTP/1.1的PUT方法自身不带验证机制， 任何人都可以 上传文件 , 存在安全性问题， 因此一般的Web网站不使用该方法。 若配合Web应用程序的验证机制， 或架构设计采用REST（REpresentational State Transfer， 表征状态转移） 标准的同类Web网站， 就可能会开放使用PUT方法。

![http](/images/blog/2019/http_put.jpg)
![http](/images/blog/2019/http_put2.jpg)

HEAD： 获得报文首部。

- HEAD方法和GET方法一样， 只是不返回报文主体部分。 用于确认URI的有效性及资源更新的日期时间等。

![http](/images/blog/2019/http_head.jpg)
![http](/images/blog/2019/http_head2.jpg)

DELETE： 删除文件。

- DELETE方法用来删除文件， 是与PUT相反的方法。DELETE方法按请求URI删除指定的资源。 但是，HTTP/1.1的DELETE方法本身和PUT方法一样不带验证机制， 所以一般的Web网站也不使用DELETE方法。 当配合Web应用程序的验证机制， 或遵守REST标准时还是有可能会开放使用的。

![http](/images/blog/2019/http_delete.jpg)
![http](/images/blog/2019/http_delete2.jpg)

OPTIONS： 询问支持的方法。

- OPTIONS方法用来查询针对请求URI指定的资源支持的方法。

![http](/images/blog/2019/http_options.jpg)
![http](/images/blog/2019/http_options2.jpg)

TRACE： 追踪路径。

- TRACE方法是让Web服务器端将之前的请求通信环回给客户端的方法。发送请求时， 在Max-Forwards首部字段中填入数值， 每经过一个服务器端就将该数字减1， 当数值刚好减到0时， 就停止继续传输， 最后接收到请求的服务器端则返回状态码200 OK的响应。客户端通过TRACE方法可以查询发送出去的请求是怎样被加工修改的。 这是因为， 请求想要连接到源目标服务器可能会通过代理中转，TRACE方法就是用来确认连接过程中发生的一系列操作。但是，TRACE方法本来就不怎么常用， 再加上它容易引发XST（Cross-Site Tracing， 跨站追踪） 攻击， 通常就更不会用到了。

![http](/images/blog/2019/http_trace.jpg)
![http](/images/blog/2019/http_trace2.jpg)

CONNECT： 要求用隧道协议连接代理。

- CONNECT方法要求在与代理服务器通信时建立隧道， 实现用隧道协议进行TCP通信。 主要使用SSL（Secure Sockets Layer， 安全套接层） 和TLS（Transport Layer Security， 传输层安全） 协议把通信内容加密后经网络隧道传输。

![http](/images/blog/2019/http_connection.jpg)
![http](/images/blog/2019/http_connection2.jpg)

持久连接节省通信量。

- HTTP 协议的初始版本中， 每进行一次 HTTP 通信就要断开一次 TCP 连接。以当年的通信情况来说，因为都是些容量很小的文本传输， 所以即使这样也没有多大问题。 可随着 HTTP 的普及， 文档中包含大量图片的情况多了起来。比如， 使用浏览器浏览一个包含多张图片的 HTML 页面时， 在发送请求访问 HTML 页面资源的同时， 也会请求该 HTML 页面里包含的其他资源。 因此， 每次的请求都会造成无谓的 TCP 连接建立和断开， 增加通信量的开销。

![http](/images/blog/2019/tcp_9.jpg)
![http](/images/blog/2019/tcp_10.jpg)

持久连接。

- 为解决上述 TCP 连接的问题， HTTP/1.1 和一部分的 HTTP/1.0 想出了持久连接（HTTP Persistent onnections， 也称为 HTTP keep-alive 或 HTTP connection reuse） 的方法。 持久连接的特点是， 只要任意一端没有明确提出断开连接， 则保持 TCP 连接状态。

![http](/images/blog/2019/tcp_11.jpg)

- 持久连接的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销， 减轻了服务器端的负载。 另外， 减少开销的那部分时间， 使 HTTP 请求和响应能够更早地结束， 这样 Web 页面的显示速度也就相应提高了。在 HTTP/1.1 中， 所有的连接默认都是持久连接， 但在 HTTP/1.0 内并未标准化。 虽然有一部分服务器通过非标准的手段实现了持久连接，但服务器端不一定能够支持持久连接。 毫无疑问， 除了服务器端， 客户端也需要支持持久连接。

管线化。

- 持久连接使得多数请求以管线化（pipelining） 方式发送成为可能。 从前发送请求后需等待并收到响应， 才能发送下一个请求。 管线化技术出现后， 不用等待响应亦可直接发送下一个请求。这样就能够做到同时并行发送多个请求， 而不需要一个接一个地等待响应了。

![http](/images/blog/2019/tcp_12.jpg)

- 比如， 当请求一个包含 10 张图片的 HTML Web 页面， 与挨个连接相比， 用持久连接可以让请求更快结束。 而管线化技术则比持久连接还要快。 请求数越多， 时间差就越明显。

使用 Cookie 的状态管理。

- HTTP 是无状态协议， 它不对之前发生过的请求和响应的状态进行管理。 也就是说， 无法根据之前的状态进行本次的请求处理。假设要求登录认证的 Web 页面本身无法进行状态的管理（不记录已登录的状态） ， 那么每次跳转新页面不是要再次登录， 就是要在每次请求报文中附加参数来管理登录状态。不可否认， 无状态协议当然也有它的优点。 由于不必保存状态， 自然可减少服务器的 CPU 及内存资源的消耗。 从另一侧面来说， 也正是因为 HTTP 协议本身是非常简单， 所以才会被应用在各种场景里。

![http](/images/blog/2019/tcp_13.jpg)

- 保留无状态协议这个特征的同时又要解决类似的矛盾问题， 于是引入了 Cookie 技术。 Cookie 技术通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的首部字段信息， 通知客户端保存 Cookie。当下次客户端再往该服务器发送请求时， 客户端会自动在请求报文中加入 Cookie 值后发送出去。服务器端发现客户端发送过来的 Cookie 后， 会去检查究竟是从哪一个客户端发来的连接请求， 然后对比服务器上的记录， 最后得到之前的状态信息。

![http](/images/blog/2019/tcp_14.jpg)
![http](/images/blog/2019/tcp_15.jpg)

上图展示了发生 Cookie 交互的情景， HTTP 请求报文和响应报文的内容如下。上图展示了发生 Cookie 交互的情景， HTTP 请求报文和响应报文的内容如下。

![http](/images/blog/2019/tcp_16.jpg)

有关请求报文和响应报文内 Cookie 对应的首部字段， 请参考之后的章节。

HTTP 报文内的 HTTP 信息。

- HTTP 通信过程包括从客户端发往服务器端的请求及从服务器端返回客户端的响应。 本章就让我们来了解一下请求和响应是怎样运作的。

HTTP 报文。

- 用于 HTTP 协议交互的信息被称为 HTTP 报文。 请求端（客户端） 的 HTTP 报文叫做请求报文， 响应端（服务器端） 的叫做响应报文。HTTP报文本身是由多行（用 CR+LF 作换行符） 数据构成的字符串文本。HTTP 报文大致可分为报文首部和报文主体两块。 两者由最初出现的空行（CR+LF） 来划分。 通常， 并不一定要有报文主体。

![http](/images/blog/2019/tcp_17.jpg)

请求报文及响应报文的结构。

![http](/images/blog/2019/tcp_18.jpg)
![http](/images/blog/2019/tcp_19.jpg)

- 请求行 ： 包含用于请求的方法， 请求 URI 和 HTTP 版本。

- 状态行 ： 包含表明响应结果的状态码， 原因短语和 HTTP 版本。

- 首部字段 ： 包含表示请求和响应的各种条件和属性的各类首部。一般有 4 种首部， 分别是： 通用首部、 请求首部、 响应首部和实体首部。

- 其他 ： 可能包含 HTTP 的 RFC 里未定义的首部（Cookie 等）。

编码提升传输速率。

- HTTP 在传输数据时可以按照数据原貌直接传输， 但也可以在传输过程中通过编码提升传输速率。 通过在传输时编码， 能有效地处理大量的访问请求。 但是， 编码的操作需要计算机来完成， 因此会消耗更多的 CPU 等资源。

- 报文主体和实体主体的差异。

- 报文（message） ： 是 HTTP 通信中的基本单位， 由 8 位组字节流（octet sequence，其中 octet 为 8 个比特） 组成， 通过 HTTP 通信传输。

- 实体（entity） : 作为请求或响应的有效载荷数据（补充项） 被传输， 其内容由实体首部和实体主体组成。

- HTTP 报文的主体用于传输请求或响应的实体主体。通常， 报文主体等于实体主体。 只有当传输中进行编码操作时， 实体主体的内容发生变化， 才导致它和报文主体产生差异。

- 向待发送邮件内增加附件时， 为了使邮件容量变小， 我们会先用 ZIP 压缩文件之后再添加附件发送。 HTTP 协议中有一种被称为内容编码的功能也能进行类似的操作。内容编码指明应用在实体内容上的编码格式， 并保持实体信息原样压缩。 内容编码后的实体由客户端接收并负责解码。

![http](/images/blog/2019/tcp_20.jpg)

常用的内容编码有以下几种：

- gzip（GNU zip）

- compress（UNIX 系统的标准压缩

- deflate（zlib）

- identity（不进行编码）

- 在 HTTP 通信过程中， 请求的编码实体资源尚未全部传输完成之前，浏览器无法显示请求页面。 在传输大容量数据时， 通过把数据分割成多块， 能够让浏览器逐步显示页面。这种把实体主体分块的功能称为分块传输编码（Chunked Transfer Coding）。

![http](/images/blog/2019/tcp_21.jpg)

- 分块传输编码会将实体主体分成多个部分（块） 。 每一块都会用十六进制来标记块的大小， 而实体主体的最后一块会使用 “0(CR+LF)” 来标记。使用分块传输编码的实体主体会由接收的客户端负责解码， 恢复到编码前的实体主体。HTTP/1.1 中存在一种称为传输编码（Transfer Coding） 的机制， 它可以在通信时按某种编码方式传输， 但只定义作用于分块传输编码中。

发送多种数据的多部分对象集合。

![http](/images/blog/2019/tcp_22.jpg)

- 发送邮件时， 我们可以在邮件里写入文字并添加多份附件。 这是因为采用了 MIME（Multipurpose Internet Mail Extensions， 多用途因特网邮件扩展） 机制， 它允许邮件处理文本、 图片、 视频等多个不同类型的53数据。 例如， 图片等二进制数据以 ASCII 码字符串编码的方式指明，就是利用 MIME 来描述标记数据类型。 而在 MIME 扩展中会使用一种称为多部分对象集合（Multipart） 的方法， 来容纳多份不同类型的数据。相应地， HTTP 协议中也采纳了多部分对象集合， 发送的一份报文主体内可含有多类型实体。 通常是在图片或文本文件等上传时使用。

- 多部分对象集合包含的对象如下：
![http](/images/blog/2019/tcp_23.jpg)
  - multipart/byteranges
  - multipart/form-data ： 在 Web 表单文件上传时使用。
  - multipart/byteranges ： 状态码 206（Partial Content， 部分内容） 响应报文包含了多个范围的内容时使用。
  - multipart/form-data ：
  - 在 HTTP 报文中使用多部分对象集合时， 需要在首部字段里加上 Content-type。 有关这个首部字段， 我们稍后讲解。使用 boundary 字符串来划分多部分对象集合指明的各类实体。 在 boundary 字符串指定的各个实体的起始行之前插入“--”标记（例如： --AaB03x、 --THIS_STRING_SEPARATES） ， 而在多部分对象集合对应的字符串的最后插入“--”标记（例如： --AaB03x--、 --THIS_STRING_SEPARATES--） 作为结束。多部分对象集合的每个部分类型中， 都可以含有首部字段。 另外， 可以在某个部分中嵌套使用多部分对象集合。

获取部分内容的范围请求。

- 以前， 用户不能使用现在这种高速的带宽访问互联网， 当时， 下载一个尺寸稍大的图片或文件就已经很吃力了。 如果下载过程中遇到网络中断的情况， 那就必须重头开始。 为了解决上述问题， 需要一种可恢复的机制。 所谓恢复是指能从之前下载中断处恢复下载。要实现该功能需要指定下载的实体范围。 像这样， 指定范围发送的请求叫做范围请求（Range Request） 。对一份 10000 字节大小的资源， 如果使用范围请求， 可以只请求 5001~10000 字节内的资源。

![http](/images/blog/2019/tcp_24.jpg)

执行范围请求时， 会用到首部字段 Range 来指定资源的 byte 范围。byte 范围的指定形式如下：

- 5001~10 000 字节 ： Range: bytes=5001-10000。

- 从 5001 字节之后全部的 ： Range: bytes=5001。

- 从一开始到 3000 字节和 5000~7000 字节的多重范围 ： Range: bytes=-3000, 5000-7000。

- 针对范围请求， 响应会返回状态码为 206 Partial Content 的响应报文。 另外， 对于多重范围的范围请求， 响应会在首部字段 ContentType标明 multipart/byteranges 后返回响应报文。如果服务器端无法响应范围请求， 则会返回状态码 200 OK 和完整的实体内容。

内容协商返回最合适的内容。

- 同一个 Web 网站有可能存在着多份相同内容的页面。 比如英语版和中文版的 Web 页面， 它们内容上虽相同， 但使用的语言却不同。当浏览器的默认语言为英语或中文， 访问相同 URI 的 Web 页面时，则会显示对应的英语版或中文版的 Web 页面。 这样的机制称为内容协商（Content Negotiation）。

![http](/images/blog/2019/tcp_25.jpg)

- 内容协商机制是指客户端和服务器端就响应的资源内容进行交涉， 然后提供给客户端最为适合的资源。 内容协商会以响应资源的语言、 字符集、 编码方式等作为判断的基准。包含在请求报文中的某些首部字段就是判断的基准。

- 内容协商技术有以下 3 种类型：

  - 服务器驱动协商（Server-driven Negotiation） ： 由服务器端进行内容协商。 以请求的首部字段为参考， 在服务器端自动处理。 但对用户来说， 以浏览器发送的信息作为判定的依据， 并不一定能筛选出最优内容。
  
  - 客户端驱动协商（Agent-driven Negotiation） ： 由客户端进行内容协商的方式。 用户从浏览器显示的可选项列表中手动选择。 还可以利用 JavaScript 脚本在 Web 页面上自动进行上述选择。 比如按 OS 的类型或浏览器类型， 自行切换成 PC 版页面或手机版页面。
  
  - 透明协商（Transparent Negotiation） ： 是服务器驱动和客户端驱动的结合体， 是由服务器端和客户端各自进行内容协商的一种方法

返回结果的 HTTP 状态码。

- HTTP 状态码负责表示客户端 HTTP 请求的返回结果、 标记服务器端的处理是否正常、 通知出现的错误等工作。

![http](/images/blog/2019/tcp_26.jpg)

- 状态码如 200 OK， 以 3 位数字和原因短语组成。数字中的第一位指定了响应类别， 后两位无分类。 响应类别有以下 5 种。

![http](/images/blog/2019/tcp_27.jpg)

只要遵守状态码类别的定义， 即使改变 RFC2616 中定义的状态码，或服务器端自行创建状态码都没问题。
- 仅记录在 RFC2616 上的 HTTP 状态码就达 40 种， 若再加上 WebDAV（Web-based Distributed Authoring and Versioning， 基于万维网的分布式创作和版本控制）和附加 HTTP 状态码 （RFC6585） 等扩展， 数量就达 60 余种。 别看种类繁多， 实际上经常使用的大概只有 14 种。 接下来， 我们就介绍一下这些具有代表性的 14 个状态码。

2XX 成功，表明请求被正常处理了。
- 200 OK ： 表示从客户端发来的请求在服务器端被正常处理了。在响应报文内， 随状态码一起返回的信息会因方法的不同而发生改变。 比如， 使用 GET 方法时， 对应请求资源的实体会作为响应返回； 而使用 HEAD方法时， 对应请求资源的实体首部不随报文主体作为响应返回（即在响应中只返回首部， 不会返回实体的主体部分） 

![http](/images/blog/2019/tcp_28.jpg)

- 204 No Content : 该状态码代表服务器接收的请求已成功处理， 但在返回的响应报文中不含实体的主体部分。另外， 也不允许返回任何实体的主体。 比如，当从浏览器发出请求处理后， 返回 204 响应， 那么浏览器显示的页面不发生更新。一般在只需要从客户端往服务器发送信息， 而对客户端不需要发送新信息内容的情况下使用。

![http](/images/blog/2019/tcp_29.jpg)

- 206 Partial Content : 该状态码表示客户端进行了范围请求， 而服务器成功执行了这部分的 GET 请求。 响应报文中包含由 Content-Range 指定范围的实体内容。

![http](/images/blog/2019/tcp_30.jpg)

3XX 重定向，表明浏览器需要执行某些特殊的处理以正确处理请求。

- 301 Moved Permanently : 永久性重定向。 该状态码表示请求的资源已被分配了新的 URI， 以后 应使用资源现在所指的 URI。 也就是说， 如果已经把资源对应的 URI 保存为书签了， 这时应该按 Location 首部字段提示的 URI 重新保存。像下方给出的请求 URI， 当指定资源路径的最后忘记添加斜杠“/”， 就会产生 301 状态码。

![http](/images/blog/2019/tcp_31.jpg)

- 302 Found : 临时性重定向。 该状态码表示请求的资源已被分配了新的 URI， 希望用户（本次） 能使用新的 URI 访问。和 301 Moved Permanently 状态码相似， 但 302 状态码代表的资源不是被永久移动，只是临时性质的。 换句话说， 已移动的资源对应的 URI 将来还有可能发生改变。 比如， 用户把 URI 保存成书签， 但不会像 301 状态码出现时那样去更新书签， 而是仍旧保留返回 302 状态码的页面对应的 URI。

![http](/images/blog/2019/tcp_32.jpg)

- 303 See Other : 该状态码表示由于请求对应的资源存在着另一个 URI， 应使用 GET 方法定向获取请求的资源。303 状态码和 302 Found 状态码有着相同的功能， 但 303 状态码明确表示客户端应当采用 GET 方法获取资源， 这点与 302 状态码有区别。比如， 当使用 POST 方法访问 CGI 程序， 其执行后的处理结果是希望客户端能以 GET 方法重定向到另一个 URI 上去时， 返回 303 状态码。 虽然 302 Found 状态码也可以实现相同的功能， 但这里使用 303 状态码是最理想的。

当 301、 302、 303 响应状态码返回时， 几乎所有的浏览器都会把 POST 改成 GET， 并删除请求报文内的主体， 之后请求会自动再次发送。301、 302 标准是禁止将 POST 方法改变成 GET 方法的， 但实际使用时大家都会这么做。

![http](/images/blog/2019/tcp_33.jpg)

- 304 Not Modified : 该状态码表示客户端发送附带条件（附带条件的请求是指采用 GET方法的请求报文中包含 If-Match， If-ModifiedSince， If-None-Match， If-Range， If-Unmodified-Since 中任一首部。）的请求时， 服务器端允许请求访问资源， 但未满足条件的情况。 304 状态码返回时， 不包含任何响应的主体部分。 304 虽然被划分在 3XX 类别中， 但是和重定向没有关 系。

![http](/images/blog/2019/tcp_34.jpg)

4XX 客户端错误，表明客户端是发生错误的原因所在。

- 400 Bad Request : 该状态码表示请求报文中存在语法错误。 当错误发生时， 需修改请求的内容后再次发送请求。 另外， 浏览器会像 200 OK 一样对待该状态码。

![http](/images/blog/2019/tcp_35.jpg)

- 401 Unauthorized : 该状态码表示发送的请求需要有通过 HTTP 认证（BASIC 认证、DIGEST 认证） 的认证信息。 另外若之前已进行过 1 次请求， 则表示用户认证失败。返回含有 401 的响应必须包含一个适用于被请求资源的 WWW-Authenticate 首部用以质询（challenge） 用户信息。 当浏览器初次接收到 401 响应， 会弹出认证用的对话窗口。

![http](/images/blog/2019/tcp_36.jpg)

- 403 Forbidden : 该状态码表明对请求资源的访问被服务器拒绝了。 服务器端没有必要给出拒绝的详细理由， 但如果想作说明的话， 可以在实体的主体部分对原因进行描述， 这样就能让用户看到了。例如，未获得文件系统的访问授权，访问权限出现某些问题（从未授权的发送源 IP 地址试图访问） 等情况。

![http](/images/blog/2019/tcp_37.jpg)

- 404 Not Found ： 该状态码表明服务器上无法找到请求的资源。 除此之外， 也可以在服务器端拒绝请求且不想说明理由时使用。

![http](/images/blog/2019/tcp_38.jpg)

5XX 服务器错误 ： 表明服务器本身发生错误。

- 500 Internal Server Error ： 该状态码表明服务器端在执行请求时发生了错误。 也有可能是 Web 应用存在的 bug 或某些临时的故障。

![http](/images/blog/2019/tcp_39.jpg)

- 503 Service Unavailable ： 该状态码表明服务器暂时处于超负载或正在进行停机维护， 现在无法处理请求。 如果事先得知解除以上状况需要的时间， 最好写入 RetryAfter 首部字段再返回给客户端。

![http](/images/blog/2019/tcp_40.jpg)

状态码和状况的不一致，不少返回的状态码响应都是错误的， 但是用户可能察觉不到这点。比如 Web 应用程序内部发生错误， 状态码依然返回 200 OK， 这种情况也经常遇到。

与 HTTP 协作的 Web 服务器。

- 一台 Web 服务器可搭建多个独立域名的 Web 网站， 也可作为通信路径上的中转服务器提升传输效率。

用单台虚拟主机实现多个域名。

- HTTP/1.1 规范允许一台 HTTP 服务器搭建多个 Web 站点。 比如， 提供 Web 托管服务（Web Hosting Service） 的供应商， 可以用一台服务器为多位客户服务， 也可以以每位客户持有的域名运行各自不同的网站。 这是因为利用了虚拟主机（Virtual Host， 又称虚拟服务器） 的功能。即使物理层面只有一台服务器， 但只要使用虚拟主机的功能， 则可以假想已具有多台服务器。

![http](/images/blog/2019/tcp_41.jpg)

- 客户端使用 HTTP 协议访问服务器时， 会经常采用类似 www.hackr.jp 这样的主机名和域名。在互联网上， 域名通过 DNS 服务映射到 IP 地址（域名解析） 之后访问目标网站。 可见， 当请求发送到服务器时， 已经是以 IP 地址形式访问了。所以， 如果一台服务器内托管了 www.tricorder.jp 和 www.hackr.jp 这两个域名， 当收到请求时就需要弄清楚究竟要访问哪个域名。在相同的 IP 地址下， 由于虚拟主机可以寄存多个不同主机名和域名的 Web 网站， 因此在发送 HTTP 请求时， 必须在 Host 首部内完整指定主机名或域名的 URI。

![http](/images/blog/2019/tcp_42.jpg)

通信数据转发程序 ： 代理、 网关、 隧道。

- HTTP 通信时， 除客户端和服务器以外， 还有一些用于通信数据转发的应用程序， 例如代理、 网关和隧道。 它们可以配合服务器工作。这些应用程序和服务器可以将请求转发给通信线路上的下一站服务器， 并且能接收从那台服务器发送的响应再转发给客户端。

- 代理 ： 代理是一种有转发功能的应用程序， 它扮演了位于服务器和客户端“中间人”的角色， 接收由客户端发送的请求并转发给服务器， 同时也接收服务器返回的响应并转发给客户端。

![http](/images/blog/2019/tcp_43.jpg)

- 代理服务器的基本行为就是接收客户端发送的请求后转发给其他服务器。 代理不改变请求 URI， 会直接发送给前方持有资源的目标服务器。持有资源实体的服务器被称为源服务器。 从源服务器返回的响应经过代理服务器后再传给客户端。

![http](/images/blog/2019/tcp_44.jpg)

- 每次通过代理服务器转发请求或响应时， 会追加写入 Via 首部信息。在 HTTP 通信过程中， 可级联多台代理服务器。请求和响应的转发会经过数台类似锁链一样连接起来的代理服务器。 转发时， 需要附加 Via 首部字段以标记出经过的主机信息。

![http](/images/blog/2019/tcp_45.jpg)

- 使用代理服务器的理由有： 利用缓存技术（稍后讲解） 减少网络带宽的流量， 组织内部针对特定网站的访问控制， 以获取访问日志为主要目的。代理有多种使用方法， 按两种基准分类。 一种是是否使用缓存， 另一种是是否会修改报文:

- 缓存代理 : 代理转发响应时， 缓存代理（Caching Proxy） 会预先将资源的副本（缓存） 保存在代理服务器上。当代理再次接收到对相同资源的请求时， 就可以不从源服务器那里获取资源， 而是将之前缓存的资源作为响应返回。

- 透明代理 : 转发请求或响应时， 不对报文做任何加工的代理类型被称为透明代理（Transparent Proxy） 。 反之， 对报文内容进行加工的代理被称为非透明代理。

- 网关 ： 网关是转发其他服务器通信数据的服务器， 接收从客户端发送来的请求时， 它就像自己拥有资源的源服务器一样对请求进行处理。 有时客户端可能都不会察觉， 自己的通信目标是一个网关。

![http](/images/blog/2019/tcp_46.jpg)

- 利用网关可以由 HTTP 请求转化为其他协议通信网关的工作机制和代理十分相似。 而网关能使通信线路上的服务器提供非 HTTP 协议服务。利用网关能提高通信的安全性， 因为可以在客户端与网关之间的通信线路上加密以确保连接的安全。 比如， 网关可以连接数据库， 使用 SQL 语句查询数据。 另外， 在 Web 购物网站上进行信用卡结算时，网关可以和信用卡结算系统联动。

- 隧道 ： 隧道是在相隔甚远的客户端和服务器两者之间进行中转， 并保持双方通信连接的应用程序。

![http](/images/blog/2019/tcp_47.jpg)

- 隧道可按要求建立起一条与其他服务器的通信线路， 届时使用 SSL 等加密手段进行通信。 隧道的目的是确保客户端能与服务器进行安全的通信。隧道本身不会去解析 HTTP 请求。 也就是说， 请求保持原样中转给之后的服务器。 隧道会在通信双方断开连接时结束。通过隧道的传输， 可以和远距离的服务器安全通信。 隧道本身是透明的， 客户端不用在意隧道的存在。

保存资源的缓存。

![http](/images/blog/2019/tcp_48.jpg)

- 缓存是指代理服务器或客户端本地磁盘内保存的资源副本。 利用缓存可减少对源服务器的访问， 因此也就节省了通信流量和通信时间。缓存服务器是代理服务器的一种， 并归类在缓存代理类型中。 换句话说， 当代理转发从服务器返回的响应时， 代理服务器将会保存一份资源的副本。缓存服务器的优势在于利用缓存可避免多次从源服务器转发资源。 因此客户端可就近从缓存服务器上获取资源， 而源服务器也不必多次处理相同的请求了。

- 即便缓存服务器内有缓存， 也不能保证每次都会返回对同资源的请求。 因为这关系到被缓存资源的有效性问题。当遇上源服务器上的资源更新时， 如果还是使用不变的缓存， 那就会演变成返回更新前的“旧”资源了。即使存在缓存， 也会因为客户端的要求、 缓存的有效期等因素， 向源服务器确认资源的有效性。 若判断缓存失效， 缓存服务器将会再次从源服务器上获取“新”资源。

![http](/images/blog/2019/tcp_49.jpg)

- 缓存不仅可以存在于缓存服务器内， 还可以存在客户端浏览器中。 以 Internet Explorer 程序为例， 把客户端缓存称为临时网络文件（Temporary Internet File） 。浏览器缓存如果有效， 就不必再向服务器请求相同的资源了， 可以直接从本地磁盘内读取。另外， 和缓存服务器相同的一点是， 当判定缓存过期后， 会向源服务器确认资源的有效性。 若判断浏览器缓存失效， 浏览器会再次请求新资源。

![http](/images/blog/2019/tcp_50.jpg)

HTTP 首部。

- HTTP 协议的请求和响应报文中必定包含 HTTP 首部， 只是我们平时在使用 Web 的过程中感受不到它。

HTTP 报文首部。

![http](/images/blog/2019/tcp_51.jpg)

- HTTP 协议的请求和响应报文中必定包含 HTTP 首部。 首部内容为客户端和服务器分别处理请求和响应提供所需要的信息。 对于客户端用户来说， 这些信息中的大部分内容都无须亲自查看。报文首部由几个字段构成：

![http](/images/blog/2019/tcp_52.jpg)

- HTTP 响应报文 ： 在响应中， HTTP 报文由 HTTP 版本、 状态码（数字和原因短语） 、HTTP 首部字段 3 部分构成。

- HTTP 请求报文 ： 在请求中， HTTP 报文由方法、 URI、 HTTP 版本、 HTTP 首部字段等部分构成。

- 在报文众多的字段当中， HTTP 首部字段包含的信息最为丰富。 首部字段同时存在于请求和响应报文内， 并涵盖 HTTP 报文相关的内容信息。

HTTP 首部字段。

- HTTP 首部字段传递重要信息 ： HTTP 首部字段是构成 HTTP 报文的要素之一。 在客户端与服务器之间以 HTTP 协议进行通信的过程中， 无论是请求还是响应都会使用首部字段， 它能起到传递额外重要信息的作用。使用首部字段是为了给浏览器和服务器提供报文主体大小、 所使用的语言、 认证信息等内容。

![http](/images/blog/2019/tcp_53.jpg)

- HTTP 首部字段结构 ： HTTP 首部字段是由首部字段名和字段值构成的， 中间用冒号 “:” 分隔。

![http](/images/blog/2019/tcp_54.jpg)

- 例如， 在 HTTP 首部中以 Content-Type 这个字段来表示报文主体的对象类型。

![http](/images/blog/2019/tcp_55.jpg)

- 就以上述示例来看， 首部字段名为 Content-Type， 字符串 text/html 是字段值。另外， 字段值对应单个 HTTP 首部字段可以有多个值， 如下所示。

![http](/images/blog/2019/tcp_56.jpg)

当 HTTP 报文首部中出现了两个或两个以上具有相同首部字段名时会怎么样？ 这种情况在规范内尚未明确， 根据浏览器内部处理逻辑的不同， 结果可能并不一致。 有些浏览器会优先处理第一次出现的首部字段， 而有些则会优先处理最后出现的首部字段。

4 种 HTTP 首部字段类型。
- 通用首部字段（General Header Fields） ： 请求报文和响应报文两方都会使用的首部。

- 请求首部字段（Request Header Fields） ： 从客户端向服务器端发送请求报文时使用的首部。 补充了请求的附加内容、 客户端信息、 响应内容相关优先级等信息。

- 响应首部字段（Response Header Fields） ： 从服务器端向客户端返回响应报文时使用的首部。 补充了响应的附加内容， 也会要求客户端附加额外的内容信息。

- 实体首部字段（Entity Header Fields） ： 针对请求报文和响应报文的实体部分使用的首部。 补充了资源内容更新时间等与实体有关的信息。

HTTP/1.1 47 种首部字段一览。

- 通用首部字段:

![http](/images/blog/2019/tcp_57.jpg)

- 请求首部字段:

![http](/images/blog/2019/tcp_58.jpg)

- 响应首部字段:

![http](/images/blog/2019/tcp_59.jpg)

- 实体首部字段:

![http](/images/blog/2019/tcp_60.jpg)

非 HTTP/1.1 首部字段。

- 在 HTTP 协议通信交互中使用到的首部字段， 不限于 RFC2616 中定义的 47 种首部字段。 还有 Cookie、 Set-Cookie 和 Content-Disposition 等在其他 RFC 中定义的首部字段， 它们的使用频率也很高。

End-to-end 首部和 Hop-by-hop 首部。

- HTTP 首部字段将定义成缓存代理和非缓存代理的行为， 分成 2 种类型。

- 端到端首部（End-to-end Header） ： 分在此类别中的首部会转发给请求 / 响应对应的最终接收目标， 且必 须保存在由缓存生成的响应中， 另外规定它必须被转发。

- 逐跳首部（Hop-by-hop Header） ： 分在此类别中的首部只对单次转发有效， 会因通过缓存或代理而不再转发。 HTTP/1.1 和之后版本中， 如果要使用 hop-by-hop 首部， 需提供 Connection 首部字段。下面列举了 HTTP/1.1 中的逐跳首部字段。 除这 8 个首部字段之外，其他所有字段都属于端到端首部：

- Connection

- Keep-Alive

- Proxy-Authenticate

- Proxy-Authorization

- Trailer

- TE

- Transfer-Encoding

- Upgrade

HTTP/1.1 通用首部字段。

- 通用首部字段是指， 请求报文和响应报文双方都会使用的首部。

Cache-Control。

- 通过指定首部字段 Cache-Control 的指令， 就能操作缓存的工作机制。

![http](/images/blog/2019/tcp_61.jpg)


首部字段 Cache-Control 能够控制缓存的行为指令的参数是可选的， 多个指令之间通过“,”分隔。 首部字段 CacheControl 的指令可用于请求及响应时。

![http](/images/blog/2019/tcp_62.jpg)

Cache-Control 可用的指令按请求和响应分类如下所示：

![http](/images/blog/2019/tcp_63.jpg)
![http](/images/blog/2019/tcp_64.jpg)

表示是否能缓存的指令 ：

- 表示是否能缓存的指令 ：

- private 指令 : 当指定 private 指令后， 响应只以特定的用户作为对象， 这与 public 指令的行为相反。缓存服务器会对该特定用户提供资源缓存的服务， 对于其他用户发送过来的请求， 代理服务器则不会返回缓存。

- no-cache 指令 ： 使用 no-cache 指令的目的是为了防止从缓存中返回过期的资源。客户端发送的请求中如果包含 no-cache 指令， 则表示客户端将不会接收缓存过的响应。 于是， “中间” 的缓存服务器必须把客户端请求转发给源服务器。如果服务器返回的响应中包含 no-cache 指令， 那么缓存服务器不能对资源进行缓存。 源服务器以后也将不再对缓存服务器请求中提出的资源有效性进行确认， 且禁止其对响应资源进行缓存操作。由服务器返回的响应中， 若报文首部字段 Cache-Control 中对 no-cache 字段名具体指定参数值， 那么客户端在接收到这个被指定参数值的首部字段对应的响应报文后， 就不能使用缓存。 换言之， 无参数值的首部字段可以使用缓存。 只能在响应指令中指定该参数。

![http](/images/blog/2019/tcp_65.jpg)

![http](/images/blog/2019/tcp_66.jpg)

![http](/images/blog/2019/tcp_67.jpg)

控制可执行缓存的对象的指令 ：

- no-store 指令 ： 当使用 no-store 指令时， 暗示请求（和对应的响应） 或响应中包含机密信息。因此， 该指令规定缓存不能在本地存储请求或响应的任一部分。

- s-maxage 指令 ： s-maxage 指令的功能和 max-age 指令的相同， 它们的不同点是 s-maxage 指令只适用于供多位用户使用的公共缓存服务器。 也就是说， 对于向同一用户重复返回响应的服务器来说， 这个指令没有任何作用。另外， 当使用 s-maxage 指令后， 则直接忽略对 Expires 首部字段及 max-age 指令的处理。

- max-age 指令 ： 当客户端发送的请求中包含 max-age 指令时， 如果判定缓存资源的缓存时间数值比指定时间的数值更小， 那么客户端就接收缓存的资源。另外， 当指定 max-age 值为0， 那么缓存服务器通常需要将请求转发给源服务器。当服务器返回的响应中包含 max-age 指令时， 缓存服务器将不对资源的有效性再作确认， 而 max-age 数值代表资源保存为缓存的最长时间。应用 HTTP/1.1 版本的缓存服务器遇到同时存在 Expires 首部字段的情况时， 会优先处理 max-age 指令， 而忽略掉 Expires 首部字段。 而 HTTP/1.0 版本的缓存服务器的情况却相反， max-age指令会被忽略掉。

![http](/images/blog/2019/tcp_68.jpg)

- 从字面意思上很容易把 **no-cache 误解成为不缓存， 但事实上 no-cache 代表不缓存过期的资源， 缓存会向源服务器进行有效期确认后处理资源， 也许称为 do-notserve-from-cache-without-revalidation 更合适。 no-store** 才是真正地不进行缓存

![http](/images/blog/2019/tcp_69.jpg)

![http](/images/blog/2019/tcp_70.jpg)

![http](/images/blog/2019/tcp_71.jpg)

- min-fresh 指令 ： min-fresh 指令要求缓存服务器返回至少还未过指定时间的缓存资源。比如， 当指定 min-fresh 为 60 秒后， 过了 60 秒的资源都无法作为响应返回了。

- max-stale 指令 : 使用 max-stale 可指示缓存资源， 即使过期也照常接收。如果指令未指定参数值， 那么无论经过多久， 客户端都会接收响应。如果指令中指定了具体数值， 那么即使过期， 只要仍处于 max-stale 指定的时间内， 仍旧会被客户端接收。

![http](/images/blog/2019/tcp_72.jpg)

- only-if-cached 指令 ： 使用 only-if-cached 指令表示客户端仅在缓存服务器本地缓存目标资源的情况下才会要求其返回。 换言之， 该指令要求缓存服务器不重新加载响应， 也不会再次确认资源有效性。 若发生请求缓存服务器的本地缓存无响应， 则返回状态码 504 Gateway Timeout。

- must-revalidate 指令 ： 使用 must-revalidate 指令， 代理会向源服务器再次验证即将返回的响应缓存目前是否仍然有效。若代理无法连通源服务器再次获取有效资源的话， 缓存必须给客户端一条 504（Gateway Timeout） 状态码。另外， 使用 must-revalidate 指令会忽略请求的max-stale 指令（即使已经在首部使用了 max-stale， 也不会再有效果）。

- proxy-revalidate 指令 : proxy-revalidate 指令要求所有的缓存服务器在接收到客户端带有该指令的请求返回响应之前， 必须再次验证缓存的有效性。

![http](/images/blog/2019/tcp_73.jpg)
![http](/images/blog/2019/tcp_74.jpg)
![http](/images/blog/2019/tcp_75.jpg)
![http](/images/blog/2019/tcp_76.jpg)

- no-transform 指令 : 使用 no-transform 指令规定无论是在请求还是响应中， 缓存都不能改变实体主体的媒体类型。这样做可防止缓存或代理压缩图片等类似操作。

Cache-Control 扩展。

- cache-extension token ： 通过 cache-extension 标记（token） ， 可以扩展 Cache-Control 首部字段内的指令。如鞋面的例子， Cache-Control 首部字段本身没有 community 这个指令。 借助 extension tokens 实现了该指令的添加。 如果缓存服务器不能理解 community这个新指令， 就会直接忽略。 因此， extension tokens 仅对能理解它的缓存服务器来说是有意义的。

![http](/images/blog/2019/tcp_77.jpg)

Connection,Connection 首部字段具备如下两个作用：

- 控制不再转发给代理的首部字段。

- 管理持久连接。

- 控制不再转发给代理的首部字段 ： 在客户端发送请求和服务器返回响应内， 使用 Connection 首部字段， 可控制不再转发给代理的首部字段（即 Hop-by-hop 首部）。

![http](/images/blog/2019/tcp_78.jpg)

- 管理持久连接 ： HTTP/1.1 版本的默认连接都是持久连接。 为此， 客户端会在持久连接上连续发送请求。当服务器端想明确断开连接时， 则指定 Connection 首部字段的值为 Close。HTTP/1.1 之前的HTTP 版本的默认连接都是非持久连接。 为此， 如果想在旧版本的 HTTP 协议上维持持续连接， 则需要指定 Connection 首部字段的值为 Keep-Alive。

![http](/images/blog/2019/tcp_79.jpg)

![http](/images/blog/2019/tcp_80.jpg)

Date:

- 首部字段 Date 表明创建 HTTP 报文的日期和时间。

![http](/images/blog/2019/tcp_81.jpg)

- HTTP/1.1 协议使用在 RFC1123 中规定的日期时间的格式， 如下示例：

![http](/images/blog/2019/tcp_82.jpg)

- 之前的 HTTP 协议版本中使用在 RFC850 中定义的格式， 如下所示：

![http](/images/blog/2019/tcp_83.jpg)

- 除此之外， 还有一种格式。 它与 C 标准库内的 asctime() 函数的输出格式一致：

![http](/images/blog/2019/tcp_84.jpg)

Pragma:

- Pragma 是 HTTP/1.1 之前版本的历史遗留字段， 仅作为与 HTTP/1.0 的向后兼容而定义。规范定义的形式唯一， 如下所示：

![http](/images/blog/2019/tcp_85.jpg)

- 该首部字段属于通用首部字段， 但只用在客户端发送的请求中。 客户端会要求所有的中间服务器不返回缓存的资源。

![http](/images/blog/2019/tcp_86.jpg)

- 所有的中间服务器如果都能以 HTTP/1.1 为基准， 那直接采用 CacheControl: no-cache 指定缓存的处理方式是最为理想的。 但要整体掌握全部中间服务器使用的 HTTP 协议版本却是不现实的。 因此， 发送的请求会同时含有下面两个首部字段。

![http](/images/blog/2019/tcp_87.jpg)

Trailer:

![http](/images/blog/2019/tcp_88.jpg)

- 首部字段 Trailer 会事先说明在报文主体后记录了哪些首部字段。 该首部字段可应用在 HTTP/1.1 版本分块传输编码时。

![http](/images/blog/2019/tcp_89.jpg)

以上用例中， 指定首部字段 Trailer 的值为 Expires ， 在报文主体之后（分块长度 0 之后） 出现了首部字段Expires 。Transfer-Encoding。

![http](/images/blog/2019/tcp_90.jpg)

- 首部字段 Transfer-Encoding 规定了传输报文主体时采用的编码方式。HTTP/1.1的传输编码方式仅对分块传输编码有效。

![http](/images/blog/2019/tcp_91.jpg)

以上用例中， 正如在首部字段 Transfer-Encoding 中指定的那样， 有效使用分块传输编码， 且分别被分成3312 字节和 914 字节大小的分块数据。

Upgrade:

- 首部字段 Upgrade 用于检测 HTTP 协议及其他协议是否可使用更高的版本进行通信， 其参数值可以用来指定一个完全不同的通信协议。

![http](/images/blog/2019/tcp_92.jpg)

- 上图用例中， 首部字段 Upgrade 指定的值为 TLS/1.0。 请注意此处两个字段首部字段的对应关系，Connection 的值被指定为 Upgrade。Upgrade 首部字段产生作用的 Upgrade 对象仅限于客户端和邻接服务器之间。 因此， 使用首部字段 Upgrade 时， 还需要额外指定 Connection:Upgrade。对于附有首部字段 Upgrade 的请求， 服务器可用 101 Switching Protocols 状态码作为响应返回。

Via:

- 使用首部字段 Via 是为了追踪客户端与服务器之间的请求和响应报文的传输路径。报文经过代理或网关时， 会先在首部字段 Via 中附加该服务器的信息， 然后再进行转发。 这个做法和 traceroute 及电子邮件的 Received 首部的工作机制很类似。首部字段 Via 不仅用于追踪报文的转发， 还可避免请求回环的发生。所以必须在经过代理时附加该首部字段内容。

![http](/images/blog/2019/tcp_93.jpg)

- 上图用例中， 在经过代理服务器 A 时， Via 首部附加了“1.0 gw.hackr.jp (Squid/3.1)”这样的字符串值。 行头的 1.0 是指接收请求的服务器上应用的 HTTP协议版本。 接下来经过代理服务器 B 时亦是如此， 在 Via 首部附加服务器信息， 也可增加 1 个新的 Via 首部写入服务器信息。Via 首部是为了追踪传输路径， 所以经常会和 TRACE 方法一起使用。 比如， 代理服务器接收到由 TRACE 方法发送过来的请求（其中 Max-Forwards: 0） 时， 代理服务器就不能再转发该请求了。 这种情况下， 代理服务器会将自身的信息附加到 Via 首部后， 返回该请求的响应。

Warning:

- HTTP/1.1 的 Warning 首部是从 HTTP/1.0 的响应首部（Retry-After） 演变过来的。 该首部通常会告知用户一些与缓存相关的问题的警告。

![http](/images/blog/2019/tcp_94.jpg)

- Warning 首部的格式如下。 最后的日期时间部分可省略。

![http](/images/blog/2019/tcp_95.jpg)

HTTP/1.1 中定义了 7 种警告。 警告码对应的警告内容仅推荐参考。另外， 警告码具备扩展性， 今后有可能追加新的警告码。

![http](/images/blog/2019/tcp_96.jpg)

响应首部字段:

![http](/images/blog/2019/tcp_97.jpg)

- 响应首部字段是由服务器端向客户端返回响应报文中所使用的字段，用于补充响应的附加信息、 服务器信息， 以及对客户端的附加要求等信息。

Accept-Ranges:

![http](/images/blog/2019/tcp_98.jpg)

当不能处理范围请求时， Accept-Ranges: none

![http](/images/blog/2019/tcp_99.jpg)

- 首部字段 Accept-Ranges 是用来告知客户端服务器是否能处理范围请求， 以指定获取服务器端某个部分的资源。可指定的字段值有两种， 可处理范围请求时指定其为 bytes， 反之则指定其为 none。

Age:

![http](/images/blog/2019/tcp_100.jpg)

- 首部字段 Age 能告知客户端， 源服务器在多久前创建了响应。 字段值的单位为秒。若创建该响应的服务器是缓存服务器， Age 值是指缓存后的响应再次发起认证到认证完成的时间值。 代理创建响应时必须加上首部字段 Age。

ETag:

![http](/images/blog/2019/tcp_101.jpg)

- 首部字段 ETag 能告知客户端实体标识。 它是一种可将资源以字符串形式做唯一性标识的方式。 服务器会为每份资源分配对应的 ETag 值。另外， 当资源更新时， ETag值也需要更新。 生成 ETag 值时， 并没有统一的算法规则， 而仅仅是由服务器来分配。

![http](/images/blog/2019/tcp_102.jpg)

- 资源被缓存时， 就会被分配唯一性标识。 例如， 当使用中文版的浏览器访问http://www.google.com/ 时， 就会返回中文版对应的资源， 而使用英文版的浏览器访问时， 则会返回英文版对应的资源。 两者的 URI 是相同的， 所以仅凭 URI指定缓存的资源是相当困难的。 若在下载过程中出现连接中断、 再连接的情况， 都会依照 ETag 值来指定资源。

- ETag 中有 强 ETag 值 和 弱 ETag 值 之分：

- 强 ETag 值 : 不论实体发生多么细微的变化都会改变其值。

- 弱 ETag 值 : 弱 ETag 值 只用于提示资源是否相同。 只有资源发生了根本改变， 产生差异时才会改变 ETag 值。 这时， 会在字段值最开始处附加 W/。

![http](/images/blog/2019/tcp_103.jpg)
![http](/images/blog/2019/tcp_104.jpg)

Location:

![http](/images/blog/2019/tcp_105.jpg)

- 使用首部字段 Location 可以将响应接收方引导至某个与请求 URI 位置不同的资源。基本上， 该字段会配合 3xx ： Redirection 的响应， 提供重定向的 URI。几乎所有的浏览器在接收到包含首部字段Location 的响应后， 都会强制性地尝试对已提示的重定向资源的访问。

Proxy-Authenticate:

![http](/images/blog/2019/tcp_106.jpg)

- 首部字段 Proxy-Authenticate 会把由代理服务器所要求的认证信息发送给客户端。它与客户端和服务器之间的 HTTP 访问认证的行为相似， 不同之处在于其认证行为是在客户端与代理之间进行的。 而客户端与服务器之间进行认证时， 首部字段 WWW-Authorization 有着相同的作用。

Retry-After:

![http](/images/blog/2019/tcp_107.jpg)

- 首部字段 Retry-After 告知客户端应该在多久之后再次发送请求。 主要配合状态码 503 Service Unavailable 响应， 或 3xx Redirect 响应一起使用。字段值可以指定为具体的日期时间（Wed, 04 Jul 2012 06： 34： 24 GMT 等格式） ， 也可以是创建响应后的秒数。

Server:

![http](/images/blog/2019/tcp_108.jpg)

- 首部字段 Server 告知客户端当前服务器上安装的 HTTP 服务器应用程序的信息。 不单单会标出服务器上的软件应用名称， 还有可能包括版本号和安装时启用的可选项。

![http](/images/blog/2019/tcp_109.jpg)

Vary:

![http](/images/blog/2019/tcp_110.jpg)

当代理服务器接收到带有 **Vary 首部字段指定获取资源的请求时， 如果使用的 Accept-Language** 字段的值相同， 那么就直接从缓存返回响应。 反之， 则需要先从源服务器端获取资源后才能作为响应返回

![http](/images/blog/2019/tcp_111.jpg)

- 首部字段 Vary 可对缓存进行控制。 源服务器会向代理服务器传达关于本地缓存使用方法的命令。从代理服务器接收到源服务器返回包含 Vary 指定项的响应之后， 若再要进行缓存， 仅对请求中含有相同Vary 指定首部字段的请求返回缓存。 即使对相同资源发起请求， 但由于 Vary 指定的首部字段不相同， 因此必须要从源服务器重新获取资源。

WWW-Authenticate:

- 首部字段 WWW-Authenticate 用于 HTTP 访问认证。 它会告知客户端适用于访问请求 URI 所指定资源的认证方案（Basic 或是 Digest） 和带参数提示的质询（challenge） 。 状态码 401 Unauthorized 响应中，肯定带有首部字段 WWW-Authenticate。

![http](/images/blog/2019/tcp_112.jpg)

realm 字段的字符串是为了辨别请求 URI 指定资源所受到的保护策略。


